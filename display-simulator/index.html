<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Display Simulator for ESPHome</title>
  </head>
  <body style="font-family: Arial, Helvetica, sans-serif;">
    <div id="display-container" style="background: #555; display: inline-block; overflow: hidden; margin-left: auto; margin-right: auto;">
      <canvas id="display" width="0" height="0" style="display: block;"></canvas>
      <div id="cursor_pos" style="color: #fff;"></div>
    </div>
    <br/>
    <textarea id="code"  rows="30" style="width: 95%;" onchange="run_code()" onkeypress="run_code()" onpaste="run_code()" oninput="run_code()">
// Draw a line from [0, 0] to [100, 50]
it.line(0, 0, 100, 50);

// Draw the outline of a rectangle with the top left at [5, 50], a width of 30 and a height of 12
it.rectangle(5, 50, 30, 12);
// Draw the same rectangle, but this time filled.
it.filled_rectangle(40, 50, 30, 12);

// Circles! Let's draw one with the center at [25, 25] and a radius of 10
it.circle(25, 25, 10);
// ... and the same thing filled again
it.filled_circle(90, 25, 10);

// Triangles... Let's draw the outline of a triangle from the [x, y] coordinates of its three points
it.triangle(25, 5, 5, 25, 50, 50);
// and a filled triangle !
it.filled_triangle(125, 5, 105, 25, 120, 50);

// Turn a single pixel off at [50, 55]
it.draw_pixel_at(50, 55, COLOR_OFF);

// Turn off a whole display portion.
it.rectangle(50, 58, 8, 4, COLOR_OFF);

// Draw a circle in the middle of the display
it.circle(it.get_width() / 2, it.get_height() / 2, 16);
    </textarea>
    <script type="text/javascript">
"use strict";

class Display {
    // Code in this class was taken from esphome/components/display/display.cpp and translated to JavaScript
    constructor() {}

    fill(color) {
        this.filled_rectangle(0, 0, this.get_width(), this.get_height(), color);
    }

    clear() {
        this.fill(this.COLOR_OFF);
    }

    line(x1, y1, x2, y2, color = this.COLOR_ON) {
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
        let dx = Math.abs(x2 - x1),
            sx = x1 < x2 ? 1 : -1;
        let dy = -Math.abs(y2 - y1),
            sy = y1 < y2 ? 1 : -1;
        let err = dx + dy;

        while (true) {
            this.draw_pixel_at(x1, y1, color);
            if (x1 == x2 && y1 == y2)
                break;
            let e2 = 2 * err;
            if (e2 >= dy) {
                err += dy;
                x1 += sx;
            }
            if (e2 <= dx) {
                err += dx;
                y1 += sy;
            }
        }
    }

    horizontal_line(x, y, width, color = this.COLOR_ON) {
        x = Math.floor(x);
        y = Math.floor(y);
        width = Math.floor(width);
        for (let i = x; i < x + width; i++)
            this.draw_pixel_at(i, y, color);
    }

    vertical_line(x, y, height, color = this.COLOR_ON) {
        x = Math.floor(x);
        y = Math.floor(y);
        height = Math.floor(height);
        for (let i = y; i < y + height; i++)
            this.draw_pixel_at(x, i, color);
    }

    rectangle(x1, y1, width, height, color = this.COLOR_ON) {
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        width = Math.floor(width);
        height = Math.floor(height);
        this.horizontal_line(x1, y1, width, color);
        this.horizontal_line(x1, y1 + height - 1, width, color);
        this.vertical_line(x1, y1, height, color);
        this.vertical_line(x1 + width - 1, y1, height, color);
    }

    filled_rectangle(x1, y1, width, height, color = this.COLOR_ON) {
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        width = Math.floor(width);
        height = Math.floor(height);
        for (let i = y1; i < y1 + height; i++) {
            this.horizontal_line(x1, i, width, color);
        }
    }

    circle(center_x, center_y, radius, color = this.COLOR_ON) {
        center_x = Math.floor(center_x);
        center_y = Math.floor(center_y);
        radius = Math.floor(radius);
        let dx = -radius;
        let dy = 0;
        let err = 2 - 2 * radius;
        let e2;

        do {
            this.draw_pixel_at(center_x - dx, center_y + dy, color);
            this.draw_pixel_at(center_x + dx, center_y + dy, color);
            this.draw_pixel_at(center_x + dx, center_y - dy, color);
            this.draw_pixel_at(center_x - dx, center_y - dy, color);
            e2 = err;
            if (e2 < dy) {
                err += ++dy * 2 + 1;
                if (-dx == dy && e2 <= dx) {
                    e2 = 0;
                }
            }
            if (e2 > dx) {
                err += ++dx * 2 + 1;
            }
        } while (dx <= 0);
    }

    filled_circle(center_x, center_y, radius, color = this.COLOR_ON) {
        center_x = Math.floor(center_x);
        center_y = Math.floor(center_y);
        radius = Math.floor(radius);
        let dx = -radius;
        let dy = 0;
        let err = 2 - 2 * radius;
        let e2;

        do {
            this.draw_pixel_at(center_x - dx, center_y + dy, color);
            this.draw_pixel_at(center_x + dx, center_y + dy, color);
            this.draw_pixel_at(center_x + dx, center_y - dy, color);
            this.draw_pixel_at(center_x - dx, center_y - dy, color);
            let hline_width = 2 * (-dx) + 1;
            this.horizontal_line(center_x + dx, center_y + dy, hline_width, color);
            this.horizontal_line(center_x + dx, center_y - dy, hline_width, color);
            e2 = err;
            if (e2 < dy) {
                err += ++dy * 2 + 1;
                if (-dx == dy && e2 <= dx) {
                    e2 = 0;
                }
            }
            if (e2 > dx) {
                err += ++dx * 2 + 1;
            }
        } while (dx <= 0);
    }

    triangle(x1, y1, x2, y2, x3, y3, color = this.COLOR_ON) {
        this.line(x1, y1, x2, y2, color);
        this.line(x1, y1, x3, y3, color);
        this.line(x2, y2, x3, y3, color);
    }

    filled_flat_side_triangle_(x1, y1, x2, y2, x3, y3, color = this.COLOR_ON) {
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
        x3 = Math.floor(x3);
        y3 = Math.floor(y3);
        // y2 must be equal to y3 (same horizontal line)

        // Initialize Bresenham's algorithm for side 1
        let s1_current_x = x1;
        let s1_current_y = y1;
        let s1_axis_swap = false;
        let s1_dx = Math.abs(x2 - x1);
        let s1_dy = Math.abs(y2 - y1);
        let s1_sign_x = ((x2 - x1) >= 0) ? 1 : -1;
        let s1_sign_y = ((y2 - y1) >= 0) ? 1 : -1;
        if (s1_dy > s1_dx) { // swap values
            [s1_dx, s1_dy] = [s1_dy, s1_dx];
            s1_axis_swap = true;
        }
        let s1_error = 2 * s1_dy - s1_dx;

        // Initialize Bresenham's algorithm for side 2
        let s2_current_x = x1;
        let s2_current_y = y1;
        let s2_axis_swap = false;
        let s2_dx = Math.abs(x3 - x1);
        let s2_dy = Math.abs(y3 - y1);
        let s2_sign_x = ((x3 - x1) >= 0) ? 1 : -1;
        let s2_sign_y = ((y3 - y1) >= 0) ? 1 : -1;
        if (s2_dy > s2_dx) { // swap values
            [s2_dx, s2_dy] = [s2_dy, s2_dx];
            s2_axis_swap = true;
        }
        let s2_error = 2 * s2_dy - s2_dx;

        // Iterate on side 1 and allow side 2 to be processed to match the advance of the y-axis.
        for (let i = 0; i <= s1_dx; i++) {
            if (s1_current_x <= s2_current_x) {
                this.horizontal_line(s1_current_x, s1_current_y, s2_current_x - s1_current_x + 1, color);
            } else {
                this.horizontal_line(s2_current_x, s2_current_y, s1_current_x - s2_current_x + 1, color);
            }

            // Bresenham's #1
            // Side 1 s1_current_x and s1_current_y calculation
            while (s1_error >= 0) {
                if (s1_axis_swap) {
                    s1_current_x += s1_sign_x;
                } else {
                    s1_current_y += s1_sign_y;
                }
                s1_error = s1_error - 2 * s1_dx;
            }
            if (s1_axis_swap) {
                s1_current_y += s1_sign_y;
            } else {
                s1_current_x += s1_sign_x;
            }
            s1_error = s1_error + 2 * s1_dy;

            // Bresenham's #2
            // Side 2 s2_current_x and s2_current_y calculation
            while (s2_current_y != s1_current_y) {
                while (s2_error >= 0) {
                    if (s2_axis_swap) {
                        s2_current_x += s2_sign_x;
                    } else {
                        s2_current_y += s2_sign_y;
                    }
                    s2_error = s2_error - 2 * s2_dx;
                }
                if (s2_axis_swap) {
                    s2_current_y += s2_sign_y;
                } else {
                    s2_current_x += s2_sign_x;
                }
                s2_error = s2_error + 2 * s2_dy;
            }
        }
    }

    filled_triangle(x1, y1, x2, y2, x3, y3, color = this.COLOR_ON) {
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
        x3 = Math.floor(x3);
        y3 = Math.floor(y3);
        // Sort the three points by y-coordinate ascending, so [x1,y1] is the topmost point
        if (y1 > y2) {
            [x1, x2] = [x2, x1];
            [y1, y2] = [y2, y1];
        }
        if (y1 > y3) {
            [x1, x3] = [x3, x1];
            [y1, y3] = [y3, y1];
        }
        if (y2 > y3) {
            [x2, x3] = [x3, x2];
            [y2, y3] = [y3, y2];
        }

        if (y2 == y3) { // Check for special case of a bottom-flat triangle
            this.filled_flat_side_triangle_(x1, y1, x2, y2, x3, y3, color);
        } else if (y1 == y2) { // Check for special case of a top-flat triangle
            this.filled_flat_side_triangle_(x3, y3, x1, y1, x2, y2, color);
        } else { // General case: split the no-flat-side triangle in a top-flat triangle and bottom-flat triangle
            let x_temp = Math.floor(x1 + ((y2 - y1) / (y3 - y1)) * (x3 - x1)),
                y_temp = y2;
            this.filled_flat_side_triangle_(x1, y1, x2, y2, x_temp, y_temp, color);
            this.filled_flat_side_triangle_(x3, y3, x2, y2, x_temp, y_temp, color);
        }
    }
}

class CanvasDisplay extends Display {
    constructor(canvas, width_pixels, height_pixels, scale = 1, pixel_border = 0, color_off = "#000", color_on = "#fff") {
        super();
        this.canvas = canvas;
        this.scale = scale * window.devicePixelRatio;
        this.pixel_border = (1 - pixel_border) * this.scale;
        this.COLOR_OFF = color_off;
        this.COLOR_ON = color_on;
        this.canvas.width = width_pixels * this.scale;
        this.canvas.height = height_pixels * this.scale;
        this.canvas.style.width = this.canvas.width;
        this.canvas.style.height = this.canvas.height;
        this.canvas.style.margin = (2 * this.scale) + "px";
        this.canvas.dataset.scale = this.scale;
        this.ctx = canvas.getContext("2d");
        this.ctx.imageSmoothingEnabled = false;
        this.ctx.fillStyle = this.COLOR_OFF;
        this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    }
    get_width() {
        return this.canvas.width / this.scale;
    }
    get_height() {
        return this.canvas.height / this.scale;
    }
    draw_pixel_at(x, y, color = this.COLOR_ON) {
        x = Math.floor(x);
        y = Math.floor(y);
        this.ctx.fillStyle = this.COLOR_OFF;
        this.ctx.fillRect(x * this.scale, y * this.scale, this.scale, this.scale);
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x * this.scale + this.pixel_border, y * this.scale + this.pixel_border, this.scale - 2 * this.pixel_border, this.scale - 2 * this.pixel_border);
    }
}

function run_code() {
    "use strict";
    let code = document.getElementById("code").value

    code = "\"use strict\";\
  let it = new CanvasDisplay(document.getElementById(\"display\"), 128, 64, 5, 0.05);\
  let COLOR_OFF = it.COLOR_OFF;\
  let COLOR_ON = it.COLOR_ON;\
  " + code;

    window.eval(code);
}
run_code();

// Tab indentation
document.getElementById("code").addEventListener("keydown", function(e) {
    if (e.key == "Tab") {
        e.preventDefault();

        let tab = "  ";

        let lines = this.value.split("\n");
        let start = this.selectionStart;
        let end = this.selectionEnd;
        let new_start = this.selectionStart;
        let new_end = this.selectionEnd;
        let start_line = 0;
        let start_index = 0;
        let end_line = lines.length - 1;
        let end_index = 0;

        for (let i = 0; i < lines.length; i++) {
            if (start <= lines[i].length) {
                start_line = i;
                start_index = start;
                break;
            }
            start -= lines[i].length + 1;
        }

        for (let i = 0; i < lines.length; i++) {
            if (end <= lines[i].length) {
                end_line = i;
                end_index = end;
                break;
            }
            end -= lines[i].length + 1;
        }

        for (let i = start_line; i <= end_line; i++) {
            if (e.shiftKey) {
                let tab_length = 0;
                if (lines[i].startsWith(tab)) {
                    tab_length = tab.length;
                } else if (lines[i].startsWith("\t")) {
                    tab_length = 1;
                }
                if (tab_length > 0) {
                    lines[i] = lines[i].substr(tab_length);
                    if (i == start_line && start_index >= tab_length) {
                        new_start -= tab_length;
                    }
                    new_end -= tab_length;
                }
            } else {
                lines[i] = tab + lines[i];
                if (i == start_line) {
                    new_start += tab.length;
                }
                new_end += tab.length;
            }
        }

        this.value = lines.join("\n")
        this.selectionStart = new_start;
        this.selectionEnd = new_end;
    }
});

// Cursor position
document.getElementById("display").addEventListener("mousemove", function(evt) {
    let display = document.getElementById("display");
    let cursor_pos = document.getElementById("cursor_pos");
    let rect = display.getBoundingClientRect();
    let x = Math.floor((evt.clientX - rect.left) / display.dataset.scale);
    let y = Math.floor((evt.clientY - rect.top) / display.dataset.scale);
    cursor_pos.textContent = x + ", " + y;
    cursor_pos.style.margin = (2 * display.dataset.scale) + "px";
    cursor_pos.style.marginTop = (-1.5 * display.dataset.scale) + "px";
    cursor_pos.style.marginBottom = (0.5 * display.dataset.scale) + "px";
}, false);
    </script>
    <p>Contains code from ESPHome licensed under <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU GPL Version 3</a></p>
  </body>
</html>
